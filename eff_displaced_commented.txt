#Get file and import addons
import ROOT as rt
import numpy as np
import time
f = rt.TFile("/usr/users/csavard/for_Alex/displacedMu_hybrid.root",'read')
tree = f.Get("L1TrackNtuple/eventTree")


#Retrive raw bin data for true particles and matched tracks
pt = []
eta = []
d0 = [] 
pt_match = []
eta_match = []
d0_match = []

ptBin = 100.
ptMin = 0.
ptMax = 100.

etaBin = 50.
etaMin = -2.5
etaMax = 2.5

d0Bin = 100.
d0Min = -10.
d0Max = 10.

for evt in tree:
     for i in evt.tp_pt:
          pt.append(i)
     for i in evt.tp_eta:
          eta.append(i)
     for i in evt.tp_d0:
          d0.append(i)
     for i in evt.matchtrk_pt:
          pt_match.append(i)
     for i in evt.matchtrk_eta:
          eta_match.append(i)
     for i in evt.matchtrk_d0:
          d0_match.append(i)

pt_compare = zip(pt,pt_match,d0)
eta_compare = zip(eta,eta_match,d0)
d0_compare = zip(d0,d0_match)

pt_compare_cut = []
eta_compare_cut = []
d0_compare_cut = []


#Make cuts to only include displaced tracks
for i in pt_compare:
     if abs(i[2]) > 0.1 and ~np.isnan(i[0]):
          pt_compare_cut.append(i)

for i in eta_compare:
     if abs(i[2]) > 0.1 and ~np.isnan(i[0]):
          eta_compare_cut.append(i)

for i in d0_compare:
     if ~np.isnan(i[0]):
          d0_compare_cut.append(i)

pt_compare.sort()
eta_compare.sort()
d0_compare.sort()

pt_compare_cut.sort()
eta_compare_cut.sort()
d0_compare_cut.sort()


#Slice arrays to only include values in the binning range
n = 0
m = 0
for i in pt_compare_cut:
     if i[0] < ptMin:
          n += 1
          m += 1
     elif ptMin <= i[0] <= ptMax:
          m += 1
     else:
          break

pt_compare_cut = pt_compare_cut[n:m+1]

n = 0
m = 0
for i in eta_compare_cut:
     if i[0] < etaMin:
          n += 1
          m += 1
     elif etaMin <= i[0] <= etaMax:
          m += 1
     else:
          break

eta_compare_cut = eta_compare_cut[n:m+1]

n = 0
m = 0
for i in d0_compare_cut:
     if i[0] < d0Min:
          n += 1
          m += 1
     elif d0Min <= i[0] <= d0Max:
          m += 1
     else:
          break

d0_compare_cut = d0_compare_cut[n:m+1]


#Preparing to generate arrays with efficiency data
pt_spacing = [0]
pt_eff = []
ptBinRange = np.arange(ptBin)
ptError = 0
ptErrorTrack = []

eta_spacing = [0]
eta_eff = []
etaBinRange = np.arange(etaBin)
etaError = 0
etaErrorTrack = []

d0_spacing = [0]
d0_eff = []
d0BinRange = np.arange(d0Bin)
d0Error = 0
d0ErrorTrack = []


#Fill arrays with efficiency per bin data  
#[int(np.sum(data_spacing):] portion optimizes code to not run thru whole array every loop
for i in ptBinRange:
     n = 0
     m = 0
     for j in pt_compare_cut[int(np.sum(pt_spacing)):]:
          if j[0] < ptMin + i*(ptMax-ptMin)/ptBin:
               pt_spacing.append(1)
          if (i <= j[0] < i+1) and (abs(j[1]) != 999):
               m += 1
               n += 1
          elif (i <= j[0] < i+1) and (abs(j[1]) == 999):
               m += 1
          elif j[0] >= i+1:
               try:
                    pt_eff.append((round(float(n)/float(m),3),n,m))
                    pt_spacing.append(m)
                    break
               except ZeroDivisionError:
                    pt_eff.append((0,0,0))
                    pt_spacing.append(0)
                    break
          else:
               ptError += 1
               ptErrorTrack.append((j[0],j[1],int(np.sum(d0_spacing))+m))
     
     
for i in etaBinRange[int(np.sum(eta_spacing)):]:
     n = 0
     m = 0
     for j in eta_compare_cut:
          if j[0] < etaMin + i*(etaMax-etaMin)/etaBin:
               eta_spacing.append(1)
          elif (etaMin + i*(etaMax-etaMin)/etaBin <= j[0] < etaMin + (i+1)*(etaMax-etaMin)/etaBin) and (abs(j[1]) != 999):
               m += 1
               n += 1
          elif (etaMin + i*(etaMax-etaMin)/etaBin <= j[0] < etaMin + (i+1)*(etaMax-etaMin)/etaBin) and (abs(j[1]) == 999):
               m += 1
          elif j[0] >= etaMin + (i+1)*(etaMax-etaMin)/etaBin:
               try:
                    eta_eff.append((round(float(n)/float(m),3),n,m))
                    eta_spacing.append(m)
                    break
               except ZeroDivisionError:
                    eta_eff.append((0,0,0))
                    eta_spacing.append(0)
                    break
          else:
               etaError += 1
               etaErrorTrack.append((j[0],j[1],int(np.sum(d0_spacing))+m))


for i in d0BinRange:
     n = 0
     m = 0
     for j in d0_compare_cut[int(np.sum(d0_spacing)):]:
          if j[0] < d0Min + i*(d0Max-d0Min)/d0Bin:
               d0_spacing.append(1)
          elif (d0Min + i*(d0Max-d0Min)/d0Bin <= j[0] < d0Min + (i+1)*(d0Max-d0Min)/d0Bin) and (np.abs(j[1]) != 999):
               m += 1
               n += 1
          elif (d0Min + i*(d0Max-d0Min)/d0Bin <= j[0] < d0Min + (i+1)*(d0Max-d0Min)/d0Bin) and (np.abs(j[1]) == 999):
               m += 1
          elif j[0] >= d0Min + (i+1)*(d0Max-d0Min)/d0Bin:
               try:
                    d0_eff.append((round(float(n)/float(m),3),n,m))
                    d0_spacing.append(m)
                    break
               except ZeroDivisionError:
                    d0_eff.append((0,0,0))
                    d0_spacing.append(0)
                    break
          else:
               d0_spacing.append(1.)
               d0Error += 1
               d0ErrorTrack.append((j[0],j[1],int(np.sum(d0_spacing))+m))


#Generate histograms
h_pt = rt.TH1F('h_pt','pT Distribution of Tracks [GeV]',int(ptBin),ptMin,ptMax)
h_eta = rt.TH1F('h_eta','#eta Distribution of Tracks',int(etaBin),etaMin,etaMax)
h_d0 = rt.TH1F('h_d0','d_{0} Distribution of Tracks [cm]',int(d0Bin),d0Min,d0Max)
h_ptMatch = rt.TH1F('h_ptMatch','pT Distribution of Matched Tracks [GeV]',int(ptBin),ptMin,ptMax)
h_etaMatch = rt.TH1F('h_etaMatch','#eta Distribution of Matched Tracks',int(etaBin),etaMin,etaMax)
h_d0Match = rt.TH1F('h_d0Match','d_{0} Distribution of Matched Tracks [cm]',int(d0Bin),d0Min,d0Max)


#Fill histograms
x=0
for i in pt_eff:
     for j in np.zeros(i[1]):
          h_ptMatch.Fill(round(ptMin + (x*(ptMax-ptMin)/ptBin) + 0.5*((ptMax-ptMin)/ptBin),3))
     for j in np.zeros(i[2]):
          h_pt.Fill(round(ptMin + (x*(ptMax-ptMin)/ptBin) + 0.5*((ptMax-ptMin)/ptBin),3))
     x += 1


x=0
for i in eta_eff:
     for j in np.zeros(i[1]):
          h_etaMatch.Fill(round(etaMin + (x*(etaMax-etaMin)/etaBin) + 0.5*((etaMax-etaMin)/etaBin),3))
     for j in np.zeros(i[2]):
          h_eta.Fill(round(etaMin + (x*(etaMax-etaMin)/etaBin) + 0.5*((etaMax-etaMin)/etaBin),3))
     x += 1


x=0
for i in d0_eff:
     for j in np.zeros(i[1]):
          h_d0Match.Fill(round(d0Min + (x*(d0Max-d0Min)/d0Bin) + 0.5*((d0Max-d0Min)/d0Bin),3))
     for j in np.zeros(i[2]):
          h_d0.Fill(round(d0Min + (x*(d0Max-d0Min)/d0Bin) + 0.5*((d0Max-d0Min)/d0Bin),3))
     x += 1


#Create efficiency plots
h_ptRatio = h_ptMatch.Clone('h_ptRatio')
h_ptRatio.Divide(h_ptMatch,h_pt,1.0,1.0)
h_ptRatio.SetTitle('pT Tracking Efficiency for |d_{0}| > 0.1 cm')
h_ptRatio.GetXaxis().SetTitle('Transverse Momentum [GeV]')
h_ptRatio.GetYaxis().SetTitle('Efficiency')
h_ptRatio.Draw()

h_etaRatio = h_etaMatch.Clone('h_etaRatio')
h_etaRatio.Divide(h_etaMatch,h_eta,1.0,1.0)
h_etaRatio.SetTitle('#eta Tracking Efficiency for |d_{0}| > 0.1 cm')
h_etaRatio.GetXaxis().SetTitle('Pseudorapidity')
h_etaRatio.GetYaxis().SetTitle('Efficiency')
h_etaRatio.Draw()

h_d0Ratio = h_d0Match.Clone('h_d0Ratio')
h_d0Ratio.Divide(h_d0Match,h_d0,1.0,1.0)
h_d0Ratio.SetTitle('d_{0} True Tracking Efficiency')
h_d0Ratio.GetXaxis().SetTitle('d_{0} [cm]')
h_d0Ratio.GetYaxis().SetTitle('Efficiency')
h_d0Ratio.Draw()